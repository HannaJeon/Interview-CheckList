# 디자인 패턴
MVC MVVM MVP 이 3가지 패턴에서 공통적으로 View와 Model은 변하지 않는다. 둘 사이에서 Controller, ViewModel, Presenter 중 어떤 형태를 사용하느냐에 따라 MVC, MVP, MVVM이 구분지어진다.
### MVC
<img src="https://www.beyondjava.net/blog/images/mvw/MVC.png" width="1200">
Model, View, Controller 각각에 대한 역할을 구분하여 독립적인 기능을 수행하도록 설계되었다.
<br>
MVC에서 View는 상태에 따라 출력형식만 달라질 뿐 모든 이벤트에 대한 제어나 가공은 Controller에 의해 처리된다. Controller는 처리해야 할 이벤트에 대하여 Model을 조작하고 그 변경사항을 표현할 View를 선택한다. 이 때, Controller는 View를 선택만 할 뿐이지 직접적인 업데이트는 하지 않는다. <br>
\*Controller와 View는 1:N 관계로, View는 Controller에서 어떤 동작이 수행되는지 알지 못한다.<br>
View의 업데이트는 아래와 같은 방법으로 이루어지게 되는데

```
- View가 Model을 직접 사용하여 업데이트
- Model에서 View에게 Notify
- View가 polling을 통해 Model의 변화를 알아채고 스스로 업데이트 하는 방법
```
이것들은 모두 Model을 참조해야 하기 때문에 View-Model간의 의존성이 생기게 된다.  
좋은 MVC패턴은 이런 View와 Model간 의존성을 최대한 낮게 구현한 것이라고 할 수 있다.  
#### 장점
- 3가지 패턴 중 구현에 있어서 가장 심플
#### 단점
- View와 Model간의 의존성을 완전히 없앨 수 없음
- 프로그램이 커질수록 가독성이 떨어지고 유지보수가 힘들어짐

### MVP
<img src="https://mblogthumb-phinf.pstatic.net/20161019_183/itperson_14768823355558NxuM_PNG/MVP.png?type=w210@2x" width="1200">
MVC에서 파생된 것으로 Model과 View간의 의존성 문제를 해결하기 위해 설계되었다.  

MVC패턴에서 Controller가 이벤트 처리만 하고 View를 업데이트 하는 것에 영향을 미치지 않는 것 과 달리, MVP의 Presenter는 모델을 조작한 결과를 다시 돌려받아서 직접 View를 업데이트 한다.  
따라서, Model과 View의 연결고리는 Presenter를 통해서만 이루어진다.  
그리고 Presenter는 View와 1:1관계를 가지고 있어 의존성이 크고 밀접한 관계를 지니므로 일반적으로 Model보다 View에 닮은 구조로 디자인 된다.  

\*참고로 애플은 MVC디자인 패턴을 채용하고 있는데 여기서 언급한 MVP패턴과 유사한 형태를 취한다.
#### 장점
- Model과 View의 의존성이 완전히 사라짐
- Model은 Presenter의 요청만 수행하면 되므로 다른 요소와의 상호 작용에 대해 신경 쓸 필요가 없음
#### 단점
- Presenter와 View간의 의존성이 큼
- MVC에 비해 필요한 Class의 수가 증가

### MVVM
<img src="https://www.beyondjava.net/blog/images/mvw/MVVM.png" width="1200">
MVC에서 파생된 모델로 Model과 View사이 분만 아니라 View와 Controller간의 의존성도 고려해 각 단위가 독립적으로 작성되고 테스트 될 수 있도록 설계된 패턴이다.  


MVP패턴에서 Presenter는 View에 의존성이 크지만, MVVM의 ViewModel은 View와 1:N 관계를 이루며 독립적으로 만들어졌다. View를 참조하지 않으므로 Model의 구조와 비슷하다.  

ViewModel은 View를 나타내주기 위한 Model이자 Presentation Logic을 처리하는 역할을 하는데, Model을 베이스로 하여 Presenteration Logic에 따라 서로 다르게 구현된다. 따라서 View에 어떤 ViewModel을 연결하느냐에 따라 로직 처리가 달라지고, Model이 변경되면 관련된 ViewModel을 사용하는 View가 자동으로 업데이트 된다.  

각각의 View는 자신이 사용할 ViewModel을 선택하여 바인딩하고 업데이트를 받게 된다. View클래스는 단순히 사용자 인터페이스를 표시하기 위한 로직만을 담당하며, 가장 이상적인 형태는 일부 사용자 인터페이스를 제외하면 오로지 메소드를 호출하는 생성자만 존재하는 것이다.  
View와 ViewModel간에는 Command와 Data Binding을 이용하게되는데, 커맨드를 통해 Behavior를 ViewMdoel에서 정의한 특정 View의 액션과 연결할 수 있으며, 데이터 바인딩을 통해 어떤 View의 속성과 ViewModel의 속성을 연결한 뒤 ViewModel 속성이 변경되면 자동으로 View를 업데이트 한다.  

#### 장점
- View가 Model이나 ViewModel과 의존성 없이 독립적
- 반복되는 이벤트 핸들러와 비즈니스 로직을 캡슐화 하여 관리할 수 있어서 재사용성이 좋다.
#### 단점
- ViewModel을 설계하는 것이 쉽지 않음
- View에 대한 처리가 복잡해질수록 ViewModel에 거대해지게 되어 오버스펙이 될 수 있음
- 플랫폼 제한적인 요소가 있음


### 싱글톤 패턴 (위의 패턴과는 달리 뷰,모델에 관한 패턴이 아님)
해당 클래스의 인스턴스가 하나만 만들어지고, 그 인스턴스에 접근할 수 있도록 하기 위한 패턴.  
정의에 따라 싱글턴 패턴은
```
 - 오로지 하나의 인스턴스만 갖도록 한다.
 - 어디서든 이 인스턴스에 접근하도록 한다.
```
의 특성을 갖는다.
#### 싱글톤 사용 이유

1) 지정한 클래스 인스턴스가 절대로 한개밖에 존재하지 않는 것을 보증하고 싶을 경우 싱글톤 패턴을 사용한다.

2) 보통 객체 생성 시 new 키워드를 사용하여 객체화 한다.  
 
객체를 생성하게 되면 그 클래스의 인스턴스는 Heap 메모리에 올라가게 되고 그 인스턴스를 가리키고 있는 변수는 Stack 메모리 영역에 생기게 된다.
이러한 작업 자체가 시간이 걸리는 일이며 한 객체를 여러번 new하게 되면 시간이 더욱 오래 걸리게 된다.

그래서 자주 사용되는 객체는 한번만 생성하고 Heap에 존재하는 이 객체를 가르키도록만 만들면 된다. 즉, 객체가 생성될 때 Heap 영역에 올라가는 시간과 메모리를 줄일 수 있다.

#### 싱글톤 단점

1) 싱글톤을 사용하여 여러곳에서 효과적으로 호출할 수 있어서 편하지만 결과적으로 프로그램의 Coupling을 높이게 되어 한곳에서의 변경이 다른 부분에 영향을 미치게 될 확률이 높아지게 된다.

2) 멀티 쓰레드 응용 프로그램에서 명시적 초기화가 필요한 경우, 쓰레딩 문제를 예방하기 위해서 조치를 취해야 한다.



### 좋은 아키텍쳐(디바인 패턴)란?
1) 프레임워크에 독립적
아키텍쳐는 라이브러리/프레임워크의 존재여부에 의존하면 안된다.
2) 테스트 용이성
비즈니스 를은 UI, DB, WebServer 또는 다른 외부 요소와 상관없이 테스트 가능해야 한다.
3) UI에 독립적
시스템의 다른 부분을 변경하지 않으면서 UI를 쉽게 변경할 수 있어야 한다.
4) DB에 독립적
현재 사용하는 DB를 다른 DB환경으로 바꾼다 해도 영향이 없어야 한다.
5) 다른 외부 요소들에 독립적
비즈니스 룰은 외부 세계에 대해 아무 것도 몰라도 된다. 그리고 어쩌면 좋은 아키텍쳐를 생각하기 전에, 내가 개발하려는 것에 굳이 디자인 패턴을 적용시켜야 하는 지에 대한 문제를 먼저 생각해봐야 할 수도 있다. 작은 규모의 모듈에 굳이 패턴을 고민하고 적용하는 것이 별 의미가 없을 수 있기 때문이다.  

따라서 각각에 대한 장단점, 내가 디자인 패턴을 사용하려고 하는 목적과 상황, 프로그램의 규모 등에 따라 가장 적절한 것을 찾아 적용하는 것이 좋은 케이스라고 할 수 있겠다.